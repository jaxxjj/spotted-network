// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v2.3.0-wicked-fork
// source: query.sql

package blacklist

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/rs/zerolog/log"
)

const blockNode = `-- name: BlockNode :one
INSERT INTO blacklist (
    peer_id,
    ip,
    reason,
    expires_at
) VALUES (
    $1,
    $2,
    $3,
    $4
)
ON CONFLICT (peer_id, ip) DO UPDATE
SET 
    reason = EXCLUDED.reason,
    expires_at = EXCLUDED.expires_at
RETURNING id, peer_id, ip, reason, created_at, expires_at
`

type BlockNodeParams struct {
	PeerID    string     `json:"peer_id"`
	Ip        string     `json:"ip"`
	Reason    *string    `json:"reason"`
	ExpiresAt *time.Time `json:"expires_at"`
}

// -- timeout: 500ms
// -- invalidate: IsBlocked
func (q *Queries) BlockNode(ctx context.Context, arg BlockNodeParams, isBlocked *IsBlockedParams) (*Blacklist, error) {
	return _BlockNode(ctx, q, arg, isBlocked)
}

func _BlockNode(ctx context.Context, q CacheWGConn, arg BlockNodeParams, isBlocked *IsBlockedParams) (*Blacklist, error) {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*500)
	defer cancel()
	row := q.GetConn().WQueryRow(qctx, "blacklist.BlockNode", blockNode,
		arg.PeerID,
		arg.Ip,
		arg.Reason,
		arg.ExpiresAt)
	var i *Blacklist = new(Blacklist)
	err := row.Scan(
		&i.ID,
		&i.PeerID,
		&i.Ip,
		&i.Reason,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	if err == pgx.ErrNoRows {
		return (*Blacklist)(nil), nil
	} else if err != nil {
		return nil, err
	}

	// invalidate
	_ = q.GetConn().PostExec(func() error {
		anyErr := make(chan error, 1)
		var wg sync.WaitGroup
		wg.Add(1)
		go func() {
			defer wg.Done()
			if isBlocked != nil {
				key := (*isBlocked).CacheKey()
				err = q.GetCache().Invalidate(ctx, key)
				if err != nil {
					log.Ctx(ctx).Error().Err(err).Msgf(
						"Failed to invalidate: %s", key)
					anyErr <- err
				}
			}
		}()
		wg.Wait()
		close(anyErr)
		return <-anyErr
	})
	return i, err
}

const cleanExpiredBlocks = `-- name: CleanExpiredBlocks :exec
DELETE FROM blacklist
WHERE expires_at < NOW()
`

// -- timeout: 5s
func (q *Queries) CleanExpiredBlocks(ctx context.Context) error {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*5000)
	defer cancel()
	_, err := q.db.WExec(qctx, "blacklist.CleanExpiredBlocks", cleanExpiredBlocks)
	if err != nil {
		return err
	}

	return nil
}

const isBlocked = `-- name: IsBlocked :one
SELECT EXISTS (
    SELECT 1 FROM blacklist
    WHERE (peer_id = $1 OR ip = $2)
    AND (expires_at IS NULL OR expires_at > NOW())
) as is_blocked
`

type IsBlockedParams struct {
	PeerID string `json:"peer_id"`
	Ip     string `json:"ip"`
}

// CacheKey - cache key
func (arg IsBlockedParams) CacheKey() string {
	prefix := "blacklist:IsBlocked:"
	return prefix + hashIfLong(fmt.Sprintf("%+v,%+v", arg.PeerID, arg.Ip))
}

// -- timeout: 100ms
// -- cache: 24h
func (q *Queries) IsBlocked(ctx context.Context, arg IsBlockedParams) (*bool, error) {
	return _IsBlocked(ctx, q.AsReadOnly(), arg)
}

func (q *ReadOnlyQueries) IsBlocked(ctx context.Context, arg IsBlockedParams) (*bool, error) {
	return _IsBlocked(ctx, q, arg)
}

func _IsBlocked(ctx context.Context, q CacheQuerierConn, arg IsBlockedParams) (*bool, error) {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*100)
	defer cancel()
	q.GetConn().CountIntent("blacklist.IsBlocked")
	dbRead := func() (any, time.Duration, error) {
		cacheDuration := time.Duration(time.Millisecond * 86400000)
		row := q.GetConn().WQueryRow(qctx, "blacklist.IsBlocked", isBlocked, arg.PeerID, arg.Ip)
		var is_blocked *bool = new(bool)
		err := row.Scan(is_blocked)
		if err == pgx.ErrNoRows {
			return (*bool)(nil), cacheDuration, nil
		}
		return is_blocked, cacheDuration, err
	}
	if q.GetCache() == nil {
		is_blocked, _, err := dbRead()
		return is_blocked.(*bool), err
	}

	var is_blocked *bool
	err := q.GetCache().GetWithTtl(qctx, arg.CacheKey(), &is_blocked, dbRead, false, false)
	if err != nil {
		return nil, err
	}

	return is_blocked, err
}

const listBlacklist = `-- name: ListBlacklist :many
SELECT id, peer_id, ip, reason, created_at, expires_at FROM blacklist
WHERE expires_at IS NULL OR expires_at > NOW()
ORDER BY created_at DESC
LIMIT COALESCE($2::int, 100)
OFFSET COALESCE($1::int, 0)
`

type ListBlacklistParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

// -- timeout: 500ms
func (q *Queries) ListBlacklist(ctx context.Context, arg ListBlacklistParams) ([]Blacklist, error) {
	return _ListBlacklist(ctx, q.AsReadOnly(), arg)
}

func (q *ReadOnlyQueries) ListBlacklist(ctx context.Context, arg ListBlacklistParams) ([]Blacklist, error) {
	return _ListBlacklist(ctx, q, arg)
}

func _ListBlacklist(ctx context.Context, q CacheQuerierConn, arg ListBlacklistParams) ([]Blacklist, error) {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*500)
	defer cancel()
	q.GetConn().CountIntent("blacklist.ListBlacklist")
	rows, err := q.GetConn().WQuery(qctx, "blacklist.ListBlacklist", listBlacklist, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Blacklist
	for rows.Next() {
		var i *Blacklist = new(Blacklist)
		if err := rows.Scan(
			&i.ID,
			&i.PeerID,
			&i.Ip,
			&i.Reason,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, *i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return items, err
}

const refreshIDSerial = `-- name: RefreshIDSerial :exec
SELECT setval(pg_get_serial_sequence('blacklist', 'id'), (SELECT MAX(id) FROM blacklist)+1, false)
`

// -- timeout: 300ms
func (q *Queries) RefreshIDSerial(ctx context.Context) error {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*300)
	defer cancel()
	_, err := q.db.WExec(qctx, "blacklist.RefreshIDSerial", refreshIDSerial)
	if err != nil {
		return err
	}

	return nil
}

const unblockNode = `-- name: UnblockNode :exec
DELETE FROM blacklist 
WHERE peer_id = $1 AND ip = $2
`

type UnblockNodeParams struct {
	PeerID string `json:"peer_id"`
	Ip     string `json:"ip"`
}

// -- timeout: 500ms
// -- invalidate: IsBlocked
func (q *Queries) UnblockNode(ctx context.Context, arg UnblockNodeParams, isBlocked *IsBlockedParams) error {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*500)
	defer cancel()
	_, err := q.db.WExec(qctx, "blacklist.UnblockNode", unblockNode, arg.PeerID, arg.Ip)
	if err != nil {
		return err
	}
	// invalidate
	_ = q.db.PostExec(func() error {
		anyErr := make(chan error, 1)
		var wg sync.WaitGroup
		wg.Add(1)
		go func() {
			defer wg.Done()
			if isBlocked != nil {
				key := (*isBlocked).CacheKey()
				err = q.cache.Invalidate(ctx, key)
				if err != nil {
					log.Ctx(ctx).Error().Err(err).Msgf(
						"Failed to invalidate: %s", key)
					anyErr <- err
				}
			}
		}()
		wg.Wait()
		close(anyErr)
		return <-anyErr
	})
	return nil
}

//// auto generated functions

func (q *Queries) Dump(ctx context.Context, beforeDump ...BeforeDump) ([]byte, error) {
	sql := "SELECT id,peer_id,ip,reason,created_at,expires_at FROM \"blacklist\" ORDER BY id,peer_id,ip,reason,created_at,expires_at ASC;"
	rows, err := q.db.WQuery(ctx, "blacklist.Dump", sql)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Blacklist
	for rows.Next() {
		var v Blacklist
		if err := rows.Scan(&v.ID, &v.PeerID, &v.Ip, &v.Reason, &v.CreatedAt, &v.ExpiresAt); err != nil {
			return nil, err
		}
		for _, applyBeforeDump := range beforeDump {
			applyBeforeDump(&v)
		}
		items = append(items, v)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	bytes, err := json.MarshalIndent(items, "", "  ")
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

func (q *Queries) Load(ctx context.Context, data []byte) error {
	sql := "INSERT INTO \"blacklist\" (id,peer_id,ip,reason,created_at,expires_at) VALUES ($1,$2,$3,$4,$5,$6);"
	rows := make([]Blacklist, 0)
	err := json.Unmarshal(data, &rows)
	if err != nil {
		return err
	}
	for _, row := range rows {
		_, err := q.db.WExec(ctx, "blacklist.Load", sql, row.ID, row.PeerID, row.Ip, row.Reason, row.CreatedAt, row.ExpiresAt)
		if err != nil {
			return err
		}
	}
	return nil
}

func hashIfLong(v string) string {
	if len(v) > 64 {
		hash := sha256.Sum256([]byte(v))
		return "h(" + hex.EncodeToString(hash[:]) + ")"
	}
	return v
}

func ptrStr[T any](v *T) string {
	if v == nil {
		return "<nil>"
	}
	return fmt.Sprintf("%+v", *v)
}

// eliminate unused error
var _ = log.Logger
var _ = fmt.Sprintf("")
var _ = time.Now()
var _ = json.RawMessage{}
var _ = sha256.Sum256(nil)
var _ = hex.EncodeToString(nil)
var _ = sync.WaitGroup{}
