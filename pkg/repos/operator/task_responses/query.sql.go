// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package task_responses

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTaskResponse = `-- name: CreateTaskResponse :one
INSERT INTO task_responses (
    task_id,
    operator_address,
    signature,
    epoch,
    chain_id,
    target_address,
    key,
    value,
    block_number,
    timestamp,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, task_id, operator_address, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at, status
`

type CreateTaskResponseParams struct {
	TaskID          string         `json:"task_id"`
	OperatorAddress string         `json:"operator_address"`
	Signature       []byte         `json:"signature"`
	Epoch           int32          `json:"epoch"`
	ChainID         int32          `json:"chain_id"`
	TargetAddress   string         `json:"target_address"`
	Key             pgtype.Numeric `json:"key"`
	Value           pgtype.Numeric `json:"value"`
	BlockNumber     pgtype.Numeric `json:"block_number"`
	Timestamp       pgtype.Numeric `json:"timestamp"`
	Status          string         `json:"status"`
}

func (q *Queries) CreateTaskResponse(ctx context.Context, arg CreateTaskResponseParams) (TaskResponse, error) {
	row := q.db.QueryRow(ctx, createTaskResponse,
		arg.TaskID,
		arg.OperatorAddress,
		arg.Signature,
		arg.Epoch,
		arg.ChainID,
		arg.TargetAddress,
		arg.Key,
		arg.Value,
		arg.BlockNumber,
		arg.Timestamp,
		arg.Status,
	)
	var i TaskResponse
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.OperatorAddress,
		&i.Signature,
		&i.Epoch,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.Value,
		&i.BlockNumber,
		&i.Timestamp,
		&i.SubmittedAt,
		&i.Status,
	)
	return i, err
}

const getOperatorResponse = `-- name: GetOperatorResponse :one
SELECT id, task_id, operator_address, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at, status FROM task_responses
WHERE task_id = $1 AND operator_address = $2
`

type GetOperatorResponseParams struct {
	TaskID          string `json:"task_id"`
	OperatorAddress string `json:"operator_address"`
}

// Get specific operator's response for a task
func (q *Queries) GetOperatorResponse(ctx context.Context, arg GetOperatorResponseParams) (TaskResponse, error) {
	row := q.db.QueryRow(ctx, getOperatorResponse, arg.TaskID, arg.OperatorAddress)
	var i TaskResponse
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.OperatorAddress,
		&i.Signature,
		&i.Epoch,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.Value,
		&i.BlockNumber,
		&i.Timestamp,
		&i.SubmittedAt,
		&i.Status,
	)
	return i, err
}

const getResponseCount = `-- name: GetResponseCount :one
SELECT COUNT(*) FROM task_responses
WHERE task_id = $1 AND status = $2
`

type GetResponseCountParams struct {
	TaskID string `json:"task_id"`
	Status string `json:"status"`
}

// Get count of responses for a task
func (q *Queries) GetResponseCount(ctx context.Context, arg GetResponseCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getResponseCount, arg.TaskID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTaskResponses = `-- name: GetTaskResponses :many
SELECT id, task_id, operator_address, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at, status FROM task_responses
WHERE task_id = $1
`

// Get all responses for a specific task
func (q *Queries) GetTaskResponses(ctx context.Context, taskID string) ([]TaskResponse, error) {
	rows, err := q.db.Query(ctx, getTaskResponses, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskResponse{}
	for rows.Next() {
		var i TaskResponse
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.OperatorAddress,
			&i.Signature,
			&i.Epoch,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.Value,
			&i.BlockNumber,
			&i.Timestamp,
			&i.SubmittedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskResponsesByStatus = `-- name: GetTaskResponsesByStatus :many
SELECT id, task_id, operator_address, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at, status FROM task_responses
WHERE task_id = $1 AND status = $2
`

type GetTaskResponsesByStatusParams struct {
	TaskID string `json:"task_id"`
	Status string `json:"status"`
}

// Get all responses for a task with specific status
func (q *Queries) GetTaskResponsesByStatus(ctx context.Context, arg GetTaskResponsesByStatusParams) ([]TaskResponse, error) {
	rows, err := q.db.Query(ctx, getTaskResponsesByStatus, arg.TaskID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskResponse{}
	for rows.Next() {
		var i TaskResponse
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.OperatorAddress,
			&i.Signature,
			&i.Epoch,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.Value,
			&i.BlockNumber,
			&i.Timestamp,
			&i.SubmittedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResponseStatus = `-- name: UpdateResponseStatus :one
UPDATE task_responses
SET status = $3
WHERE task_id = $1 AND operator_address = $2
RETURNING id, task_id, operator_address, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at, status
`

type UpdateResponseStatusParams struct {
	TaskID          string `json:"task_id"`
	OperatorAddress string `json:"operator_address"`
	Status          string `json:"status"`
}

// Update response status
func (q *Queries) UpdateResponseStatus(ctx context.Context, arg UpdateResponseStatusParams) (TaskResponse, error) {
	row := q.db.QueryRow(ctx, updateResponseStatus, arg.TaskID, arg.OperatorAddress, arg.Status)
	var i TaskResponse
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.OperatorAddress,
		&i.Signature,
		&i.Epoch,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.Value,
		&i.BlockNumber,
		&i.Timestamp,
		&i.SubmittedAt,
		&i.Status,
	)
	return i, err
}
