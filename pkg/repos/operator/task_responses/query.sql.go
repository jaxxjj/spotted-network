// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package task_responses

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTaskResponse = `-- name: CreateTaskResponse :one
INSERT INTO task_responses (
    task_id,
    operator_address,
    signing_key,
    signature,
    epoch,
    chain_id,
    target_address,
    key,
    value,
    block_number,
    timestamp
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, task_id, operator_address, signing_key, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at
`

type CreateTaskResponseParams struct {
	TaskID          string         `json:"task_id"`
	OperatorAddress string         `json:"operator_address"`
	SigningKey      string         `json:"signing_key"`
	Signature       []byte         `json:"signature"`
	Epoch           int32          `json:"epoch"`
	ChainID         int32          `json:"chain_id"`
	TargetAddress   string         `json:"target_address"`
	Key             pgtype.Numeric `json:"key"`
	Value           pgtype.Numeric `json:"value"`
	BlockNumber     pgtype.Numeric `json:"block_number"`
	Timestamp       pgtype.Numeric `json:"timestamp"`
}

func (q *Queries) CreateTaskResponse(ctx context.Context, arg CreateTaskResponseParams) (TaskResponse, error) {
	row := q.db.QueryRow(ctx, createTaskResponse,
		arg.TaskID,
		arg.OperatorAddress,
		arg.SigningKey,
		arg.Signature,
		arg.Epoch,
		arg.ChainID,
		arg.TargetAddress,
		arg.Key,
		arg.Value,
		arg.BlockNumber,
		arg.Timestamp,
	)
	var i TaskResponse
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.OperatorAddress,
		&i.SigningKey,
		&i.Signature,
		&i.Epoch,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.Value,
		&i.BlockNumber,
		&i.Timestamp,
		&i.SubmittedAt,
	)
	return i, err
}

const deleteTaskResponse = `-- name: DeleteTaskResponse :exec
DELETE FROM task_responses
WHERE task_id = $1 AND operator_address = $2
`

type DeleteTaskResponseParams struct {
	TaskID          string `json:"task_id"`
	OperatorAddress string `json:"operator_address"`
}

func (q *Queries) DeleteTaskResponse(ctx context.Context, arg DeleteTaskResponseParams) error {
	_, err := q.db.Exec(ctx, deleteTaskResponse, arg.TaskID, arg.OperatorAddress)
	return err
}

const getTaskResponse = `-- name: GetTaskResponse :one
SELECT id, task_id, operator_address, signing_key, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at FROM task_responses
WHERE task_id = $1 AND operator_address = $2
`

type GetTaskResponseParams struct {
	TaskID          string `json:"task_id"`
	OperatorAddress string `json:"operator_address"`
}

func (q *Queries) GetTaskResponse(ctx context.Context, arg GetTaskResponseParams) (TaskResponse, error) {
	row := q.db.QueryRow(ctx, getTaskResponse, arg.TaskID, arg.OperatorAddress)
	var i TaskResponse
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.OperatorAddress,
		&i.SigningKey,
		&i.Signature,
		&i.Epoch,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.Value,
		&i.BlockNumber,
		&i.Timestamp,
		&i.SubmittedAt,
	)
	return i, err
}

const listOperatorResponses = `-- name: ListOperatorResponses :many
SELECT id, task_id, operator_address, signing_key, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at FROM task_responses
WHERE operator_address = $1
ORDER BY submitted_at DESC
LIMIT $2
`

type ListOperatorResponsesParams struct {
	OperatorAddress string `json:"operator_address"`
	Limit           int32  `json:"limit"`
}

func (q *Queries) ListOperatorResponses(ctx context.Context, arg ListOperatorResponsesParams) ([]TaskResponse, error) {
	rows, err := q.db.Query(ctx, listOperatorResponses, arg.OperatorAddress, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskResponse{}
	for rows.Next() {
		var i TaskResponse
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.OperatorAddress,
			&i.SigningKey,
			&i.Signature,
			&i.Epoch,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.Value,
			&i.BlockNumber,
			&i.Timestamp,
			&i.SubmittedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskResponses = `-- name: ListTaskResponses :many
SELECT id, task_id, operator_address, signing_key, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at FROM task_responses
WHERE task_id = $1
`

func (q *Queries) ListTaskResponses(ctx context.Context, taskID string) ([]TaskResponse, error) {
	rows, err := q.db.Query(ctx, listTaskResponses, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskResponse{}
	for rows.Next() {
		var i TaskResponse
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.OperatorAddress,
			&i.SigningKey,
			&i.Signature,
			&i.Epoch,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.Value,
			&i.BlockNumber,
			&i.Timestamp,
			&i.SubmittedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
