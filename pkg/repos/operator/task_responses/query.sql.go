// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v2.3.0-wicked-fork
// source: query.sql

package task_responses

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/rs/zerolog/log"
)

const createTaskResponse = `-- name: CreateTaskResponse :one
INSERT INTO task_responses (
    task_id,
    operator_address,
    signing_key,
    signature,
    epoch,
    chain_id,
    target_address,
    key,
    value,
    block_number,
    timestamp
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, task_id, operator_address, signing_key, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at
`

type CreateTaskResponseParams struct {
	TaskID          string         `json:"task_id"`
	OperatorAddress string         `json:"operator_address"`
	SigningKey      string         `json:"signing_key"`
	Signature       []byte         `json:"signature"`
	Epoch           uint32         `json:"epoch"`
	ChainID         uint32         `json:"chain_id"`
	TargetAddress   string         `json:"target_address"`
	Key             pgtype.Numeric `json:"key"`
	Value           pgtype.Numeric `json:"value"`
	BlockNumber     uint64         `json:"block_number"`
	Timestamp       uint64         `json:"timestamp"`
}

// -- invalidate: GetTaskResponse
// -- timeout: 500ms
func (q *Queries) CreateTaskResponse(ctx context.Context, arg CreateTaskResponseParams, getTaskResponse *GetTaskResponseParams) (*TaskResponses, error) {
	return _CreateTaskResponse(ctx, q, arg, getTaskResponse)
}

func _CreateTaskResponse(ctx context.Context, q CacheWGConn, arg CreateTaskResponseParams, getTaskResponse *GetTaskResponseParams) (*TaskResponses, error) {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*500)
	defer cancel()
	row := q.GetConn().WQueryRow(qctx, "task_responses.CreateTaskResponse", createTaskResponse,
		arg.TaskID,
		arg.OperatorAddress,
		arg.SigningKey,
		arg.Signature,
		arg.Epoch,
		arg.ChainID,
		arg.TargetAddress,
		arg.Key,
		arg.Value,
		arg.BlockNumber,
		arg.Timestamp)
	var i *TaskResponses = new(TaskResponses)
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.OperatorAddress,
		&i.SigningKey,
		&i.Signature,
		&i.Epoch,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.Value,
		&i.BlockNumber,
		&i.Timestamp,
		&i.SubmittedAt,
	)
	if err == pgx.ErrNoRows {
		return (*TaskResponses)(nil), nil
	} else if err != nil {
		return nil, err
	}

	// invalidate
	_ = q.GetConn().PostExec(func() error {
		anyErr := make(chan error, 1)
		var wg sync.WaitGroup
		wg.Add(1)
		go func() {
			defer wg.Done()
			if getTaskResponse != nil {
				key := (*getTaskResponse).CacheKey()
				err = q.GetCache().Invalidate(ctx, key)
				if err != nil {
					log.Ctx(ctx).Error().Err(err).Msgf(
						"Failed to invalidate: %s", key)
					anyErr <- err
				}
			}
		}()
		wg.Wait()
		close(anyErr)
		return <-anyErr
	})
	return i, err
}

const deleteTaskResponse = `-- name: DeleteTaskResponse :exec
DELETE FROM task_responses
WHERE task_id = $1 AND operator_address = $2
`

type DeleteTaskResponseParams struct {
	TaskID          string `json:"task_id"`
	OperatorAddress string `json:"operator_address"`
}

// -- invalidate: GetTaskResponse
// -- timeout: 500ms
func (q *Queries) DeleteTaskResponse(ctx context.Context, arg DeleteTaskResponseParams, getTaskResponse *GetTaskResponseParams) error {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*500)
	defer cancel()
	_, err := q.db.WExec(qctx, "task_responses.DeleteTaskResponse", deleteTaskResponse, arg.TaskID, arg.OperatorAddress)
	if err != nil {
		return err
	}
	// invalidate
	_ = q.db.PostExec(func() error {
		anyErr := make(chan error, 1)
		var wg sync.WaitGroup
		wg.Add(1)
		go func() {
			defer wg.Done()
			if getTaskResponse != nil {
				key := (*getTaskResponse).CacheKey()
				err = q.cache.Invalidate(ctx, key)
				if err != nil {
					log.Ctx(ctx).Error().Err(err).Msgf(
						"Failed to invalidate: %s", key)
					anyErr <- err
				}
			}
		}()
		wg.Wait()
		close(anyErr)
		return <-anyErr
	})
	return nil
}

const getTaskResponse = `-- name: GetTaskResponse :one
SELECT id, task_id, operator_address, signing_key, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at FROM task_responses
WHERE task_id = $1 AND operator_address = $2
`

type GetTaskResponseParams struct {
	TaskID          string `json:"task_id"`
	OperatorAddress string `json:"operator_address"`
}

// CacheKey - cache key
func (arg GetTaskResponseParams) CacheKey() string {
	prefix := "task_responses:GetTaskResponse:"
	return prefix + hashIfLong(fmt.Sprintf("%+v,%+v", arg.TaskID, arg.OperatorAddress))
}

// Get single task response by task_id and operator_address
// -- cache: 168h
// -- timeout: 500ms
func (q *Queries) GetTaskResponse(ctx context.Context, arg GetTaskResponseParams) (*TaskResponses, error) {
	return _GetTaskResponse(ctx, q.AsReadOnly(), arg)
}

func (q *ReadOnlyQueries) GetTaskResponse(ctx context.Context, arg GetTaskResponseParams) (*TaskResponses, error) {
	return _GetTaskResponse(ctx, q, arg)
}

func _GetTaskResponse(ctx context.Context, q CacheQuerierConn, arg GetTaskResponseParams) (*TaskResponses, error) {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*500)
	defer cancel()
	q.GetConn().CountIntent("task_responses.GetTaskResponse")
	dbRead := func() (any, time.Duration, error) {
		cacheDuration := time.Duration(time.Millisecond * 604800000)
		row := q.GetConn().WQueryRow(qctx, "task_responses.GetTaskResponse", getTaskResponse, arg.TaskID, arg.OperatorAddress)
		var i *TaskResponses = new(TaskResponses)
		err := row.Scan(
			&i.ID,
			&i.TaskID,
			&i.OperatorAddress,
			&i.SigningKey,
			&i.Signature,
			&i.Epoch,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.Value,
			&i.BlockNumber,
			&i.Timestamp,
			&i.SubmittedAt,
		)
		if err == pgx.ErrNoRows {
			return (*TaskResponses)(nil), cacheDuration, nil
		}
		return i, cacheDuration, err
	}
	if q.GetCache() == nil {
		i, _, err := dbRead()
		return i.(*TaskResponses), err
	}

	var i *TaskResponses
	err := q.GetCache().GetWithTtl(qctx, arg.CacheKey(), &i, dbRead, false, false)
	if err != nil {
		return nil, err
	}

	return i, err
}

const listOperatorResponses = `-- name: ListOperatorResponses :many
SELECT id, task_id, operator_address, signing_key, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at FROM task_responses
WHERE operator_address = $1
ORDER BY submitted_at DESC
LIMIT $2
`

type ListOperatorResponsesParams struct {
	OperatorAddress string `json:"operator_address"`
	Limit           int32  `json:"limit"`
}

// Get recent responses for an operator, no cache for real-time data
// -- timeout: 1s
func (q *Queries) ListOperatorResponses(ctx context.Context, arg ListOperatorResponsesParams) ([]TaskResponses, error) {
	return _ListOperatorResponses(ctx, q.AsReadOnly(), arg)
}

func (q *ReadOnlyQueries) ListOperatorResponses(ctx context.Context, arg ListOperatorResponsesParams) ([]TaskResponses, error) {
	return _ListOperatorResponses(ctx, q, arg)
}

func _ListOperatorResponses(ctx context.Context, q CacheQuerierConn, arg ListOperatorResponsesParams) ([]TaskResponses, error) {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*1000)
	defer cancel()
	q.GetConn().CountIntent("task_responses.ListOperatorResponses")
	rows, err := q.GetConn().WQuery(qctx, "task_responses.ListOperatorResponses", listOperatorResponses, arg.OperatorAddress, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskResponses
	for rows.Next() {
		var i *TaskResponses = new(TaskResponses)
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.OperatorAddress,
			&i.SigningKey,
			&i.Signature,
			&i.Epoch,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.Value,
			&i.BlockNumber,
			&i.Timestamp,
			&i.SubmittedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, *i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return items, err
}

const listTaskResponses = `-- name: ListTaskResponses :many
SELECT id, task_id, operator_address, signing_key, signature, epoch, chain_id, target_address, key, value, block_number, timestamp, submitted_at FROM task_responses
WHERE task_id = $1
`

// Get all responses for a task, no cache for real-time data
// -- timeout: 1s
func (q *Queries) ListTaskResponses(ctx context.Context, taskID string) ([]TaskResponses, error) {
	return _ListTaskResponses(ctx, q.AsReadOnly(), taskID)
}

func (q *ReadOnlyQueries) ListTaskResponses(ctx context.Context, taskID string) ([]TaskResponses, error) {
	return _ListTaskResponses(ctx, q, taskID)
}

func _ListTaskResponses(ctx context.Context, q CacheQuerierConn, taskID string) ([]TaskResponses, error) {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*1000)
	defer cancel()
	q.GetConn().CountIntent("task_responses.ListTaskResponses")
	rows, err := q.GetConn().WQuery(qctx, "task_responses.ListTaskResponses", listTaskResponses, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskResponses
	for rows.Next() {
		var i *TaskResponses = new(TaskResponses)
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.OperatorAddress,
			&i.SigningKey,
			&i.Signature,
			&i.Epoch,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.Value,
			&i.BlockNumber,
			&i.Timestamp,
			&i.SubmittedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, *i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return items, err
}

//// auto generated functions

func (q *Queries) Dump(ctx context.Context, beforeDump ...BeforeDump) ([]byte, error) {
	sql := "SELECT id,task_id,operator_address,signing_key,signature,epoch,chain_id,target_address,key,value,block_number,timestamp,submitted_at FROM \"task_responses\" ORDER BY id,task_id,operator_address,signing_key,target_address,submitted_at ASC;"
	rows, err := q.db.WQuery(ctx, "task_responses.Dump", sql)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskResponses
	for rows.Next() {
		var v TaskResponses
		if err := rows.Scan(&v.ID, &v.TaskID, &v.OperatorAddress, &v.SigningKey, &v.Signature, &v.Epoch, &v.ChainID, &v.TargetAddress, &v.Key, &v.Value, &v.BlockNumber, &v.Timestamp, &v.SubmittedAt); err != nil {
			return nil, err
		}
		for _, applyBeforeDump := range beforeDump {
			applyBeforeDump(&v)
		}
		items = append(items, v)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	bytes, err := json.MarshalIndent(items, "", "  ")
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

func (q *Queries) Load(ctx context.Context, data []byte) error {
	sql := "INSERT INTO \"task_responses\" (id,task_id,operator_address,signing_key,signature,epoch,chain_id,target_address,key,value,block_number,timestamp,submitted_at) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13);"
	rows := make([]TaskResponses, 0)
	err := json.Unmarshal(data, &rows)
	if err != nil {
		return err
	}
	for _, row := range rows {
		_, err := q.db.WExec(ctx, "task_responses.Load", sql, row.ID, row.TaskID, row.OperatorAddress, row.SigningKey, row.Signature, row.Epoch, row.ChainID, row.TargetAddress, row.Key, row.Value, row.BlockNumber, row.Timestamp, row.SubmittedAt)
		if err != nil {
			return err
		}
	}
	return nil
}

func hashIfLong(v string) string {
	if len(v) > 64 {
		hash := sha256.Sum256([]byte(v))
		return "h(" + hex.EncodeToString(hash[:]) + ")"
	}
	return v
}

func ptrStr[T any](v *T) string {
	if v == nil {
		return "<nil>"
	}
	return fmt.Sprintf("%+v", *v)
}

// eliminate unused error
var _ = log.Logger
var _ = fmt.Sprintf("")
var _ = time.Now()
var _ = json.RawMessage{}
var _ = sha256.Sum256(nil)
var _ = hex.EncodeToString(nil)
var _ = sync.WaitGroup{}
