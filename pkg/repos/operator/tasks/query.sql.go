// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package tasks

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldTasks = `-- name: CleanupOldTasks :exec
DELETE FROM tasks
WHERE created_at < NOW() - INTERVAL '24 hours'
AND status IN ('completed', 'expired', 'failed')
`

func (q *Queries) CleanupOldTasks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldTasks)
	return err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
    task_id,
    target_address,
    chain_id,
    block_number,
    timestamp,
    epoch,
    key,
    value,
    expire_time,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING task_id, target_address, chain_id, block_number, timestamp, epoch, key, value, expire_time, retries, status, created_at
`

type CreateTaskParams struct {
	TaskID        string           `json:"task_id"`
	TargetAddress string           `json:"target_address"`
	ChainID       int32            `json:"chain_id"`
	BlockNumber   pgtype.Numeric   `json:"block_number"`
	Timestamp     pgtype.Numeric   `json:"timestamp"`
	Epoch         int32            `json:"epoch"`
	Key           pgtype.Numeric   `json:"key"`
	Value         pgtype.Numeric   `json:"value"`
	ExpireTime    pgtype.Timestamp `json:"expire_time"`
	Status        string           `json:"status"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.TaskID,
		arg.TargetAddress,
		arg.ChainID,
		arg.BlockNumber,
		arg.Timestamp,
		arg.Epoch,
		arg.Key,
		arg.Value,
		arg.ExpireTime,
		arg.Status,
	)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.TargetAddress,
		&i.ChainID,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Epoch,
		&i.Key,
		&i.Value,
		&i.ExpireTime,
		&i.Retries,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT task_id, target_address, chain_id, block_number, timestamp, epoch, key, value, expire_time, retries, status, created_at FROM tasks
WHERE task_id = $1
`

func (q *Queries) GetTaskByID(ctx context.Context, taskID string) (Task, error) {
	row := q.db.QueryRow(ctx, getTaskByID, taskID)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.TargetAddress,
		&i.ChainID,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Epoch,
		&i.Key,
		&i.Value,
		&i.ExpireTime,
		&i.Retries,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const listExpiredTasks = `-- name: ListExpiredTasks :many
SELECT task_id, target_address, chain_id, block_number, timestamp, epoch, key, value, expire_time, retries, status, created_at FROM tasks
WHERE status = 'pending'
AND expire_time <= NOW()
ORDER BY created_at ASC
`

func (q *Queries) ListExpiredTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.Query(ctx, listExpiredTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.TaskID,
			&i.TargetAddress,
			&i.ChainID,
			&i.BlockNumber,
			&i.Timestamp,
			&i.Epoch,
			&i.Key,
			&i.Value,
			&i.ExpireTime,
			&i.Retries,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingTasks = `-- name: ListPendingTasks :many
SELECT task_id, target_address, chain_id, block_number, timestamp, epoch, key, value, expire_time, retries, status, created_at FROM tasks
WHERE status = 'pending'
AND expire_time > NOW()
ORDER BY created_at ASC
`

func (q *Queries) ListPendingTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.Query(ctx, listPendingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.TaskID,
			&i.TargetAddress,
			&i.ChainID,
			&i.BlockNumber,
			&i.Timestamp,
			&i.Epoch,
			&i.Key,
			&i.Value,
			&i.ExpireTime,
			&i.Retries,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTaskStatus = `-- name: UpdateTaskStatus :one
UPDATE tasks
SET status = $2,
    retries = CASE 
        WHEN $2 = 'pending' THEN retries + 1
        ELSE retries
    END
WHERE task_id = $1
RETURNING task_id, target_address, chain_id, block_number, timestamp, epoch, key, value, expire_time, retries, status, created_at
`

type UpdateTaskStatusParams struct {
	TaskID string `json:"task_id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (Task, error) {
	row := q.db.QueryRow(ctx, updateTaskStatus, arg.TaskID, arg.Status)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.TargetAddress,
		&i.ChainID,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Epoch,
		&i.Key,
		&i.Value,
		&i.ExpireTime,
		&i.Retries,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const updateTaskValue = `-- name: UpdateTaskValue :one
UPDATE tasks
SET value = $2,
    status = 'pending'
WHERE task_id = $1
RETURNING task_id, target_address, chain_id, block_number, timestamp, epoch, key, value, expire_time, retries, status, created_at
`

type UpdateTaskValueParams struct {
	TaskID string         `json:"task_id"`
	Value  pgtype.Numeric `json:"value"`
}

func (q *Queries) UpdateTaskValue(ctx context.Context, arg UpdateTaskValueParams) (Task, error) {
	row := q.db.QueryRow(ctx, updateTaskValue, arg.TaskID, arg.Value)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.TargetAddress,
		&i.ChainID,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Epoch,
		&i.Key,
		&i.Value,
		&i.ExpireTime,
		&i.Retries,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}
