// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package tasks

import (
	"context"

	types "github.com/galxe/spotted-network/pkg/common/types"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldTasks = `-- name: CleanupOldTasks :exec
DELETE FROM tasks
WHERE created_at < NOW() - INTERVAL '24 hours'
AND status IN ('completed')
`

func (q *Queries) CleanupOldTasks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldTasks)
	return err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
    task_id,
    target_address,
    chain_id,
    block_number,
    timestamp,
    epoch,
    key,
    value,
    status,
    required_confirmations
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, retry_count, created_at, updated_at
`

type CreateTaskParams struct {
	TaskID                string           `json:"task_id"`
	TargetAddress         string           `json:"target_address"`
	ChainID               uint32           `json:"chain_id"`
	BlockNumber           uint64           `json:"block_number"`
	Timestamp             uint64           `json:"timestamp"`
	Epoch                 uint32           `json:"epoch"`
	Key                   pgtype.Numeric   `json:"key"`
	Value                 pgtype.Numeric   `json:"value"`
	Status                types.TaskStatus `json:"status"`
	RequiredConfirmations uint16           `json:"required_confirmations"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Tasks, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.TaskID,
		arg.TargetAddress,
		arg.ChainID,
		arg.BlockNumber,
		arg.Timestamp,
		arg.Epoch,
		arg.Key,
		arg.Value,
		arg.Status,
		arg.RequiredConfirmations,
	)
	var i Tasks
	err := row.Scan(
		&i.TaskID,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Value,
		&i.Epoch,
		&i.Status,
		&i.RequiredConfirmations,
		&i.RetryCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTaskByID = `-- name: DeleteTaskByID :exec
DELETE FROM tasks
WHERE task_id = $1
`

func (q *Queries) DeleteTaskByID(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, deleteTaskByID, taskID)
	return err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, retry_count, created_at, updated_at FROM tasks
WHERE task_id = $1
`

func (q *Queries) GetTaskByID(ctx context.Context, taskID string) (Tasks, error) {
	row := q.db.QueryRow(ctx, getTaskByID, taskID)
	var i Tasks
	err := row.Scan(
		&i.TaskID,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Value,
		&i.Epoch,
		&i.Status,
		&i.RequiredConfirmations,
		&i.RetryCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementRetryCount = `-- name: IncrementRetryCount :one
UPDATE tasks
SET retry_count = retry_count + 1,
    updated_at = NOW()
WHERE task_id = $1
RETURNING task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, retry_count, created_at, updated_at
`

func (q *Queries) IncrementRetryCount(ctx context.Context, taskID string) (Tasks, error) {
	row := q.db.QueryRow(ctx, incrementRetryCount, taskID)
	var i Tasks
	err := row.Scan(
		&i.TaskID,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Value,
		&i.Epoch,
		&i.Status,
		&i.RequiredConfirmations,
		&i.RetryCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllTasks = `-- name: ListAllTasks :many
SELECT task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, retry_count, created_at, updated_at FROM tasks ORDER BY created_at DESC
`

func (q *Queries) ListAllTasks(ctx context.Context) ([]Tasks, error) {
	rows, err := q.db.Query(ctx, listAllTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tasks{}
	for rows.Next() {
		var i Tasks
		if err := rows.Scan(
			&i.TaskID,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.BlockNumber,
			&i.Timestamp,
			&i.Value,
			&i.Epoch,
			&i.Status,
			&i.RequiredConfirmations,
			&i.RetryCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConfirmingTasks = `-- name: ListConfirmingTasks :many
SELECT task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, retry_count, created_at, updated_at FROM tasks 
WHERE status = 'confirming'
ORDER BY created_at DESC
`

func (q *Queries) ListConfirmingTasks(ctx context.Context) ([]Tasks, error) {
	rows, err := q.db.Query(ctx, listConfirmingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tasks{}
	for rows.Next() {
		var i Tasks
		if err := rows.Scan(
			&i.TaskID,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.BlockNumber,
			&i.Timestamp,
			&i.Value,
			&i.Epoch,
			&i.Status,
			&i.RequiredConfirmations,
			&i.RetryCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingTasks = `-- name: ListPendingTasks :many
SELECT task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, retry_count, created_at, updated_at FROM tasks
WHERE status = 'pending'
ORDER BY created_at ASC
`

func (q *Queries) ListPendingTasks(ctx context.Context) ([]Tasks, error) {
	rows, err := q.db.Query(ctx, listPendingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tasks{}
	for rows.Next() {
		var i Tasks
		if err := rows.Scan(
			&i.TaskID,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.BlockNumber,
			&i.Timestamp,
			&i.Value,
			&i.Epoch,
			&i.Status,
			&i.RequiredConfirmations,
			&i.RetryCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTaskCompleted = `-- name: UpdateTaskCompleted :exec
UPDATE tasks
SET status = 'completed',
    updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskCompleted(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, updateTaskCompleted, taskID)
	return err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :one
UPDATE tasks
SET status = $2,
    updated_at = NOW()
WHERE task_id = $1
RETURNING task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, retry_count, created_at, updated_at
`

type UpdateTaskStatusParams struct {
	TaskID string           `json:"task_id"`
	Status types.TaskStatus `json:"status"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (Tasks, error) {
	row := q.db.QueryRow(ctx, updateTaskStatus, arg.TaskID, arg.Status)
	var i Tasks
	err := row.Scan(
		&i.TaskID,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Value,
		&i.Epoch,
		&i.Status,
		&i.RequiredConfirmations,
		&i.RetryCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTaskToPending = `-- name: UpdateTaskToPending :exec
UPDATE tasks 
SET status = 'pending', 
    updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskToPending(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, updateTaskToPending, taskID)
	return err
}

const updateTaskValue = `-- name: UpdateTaskValue :one
UPDATE tasks
SET value = $2,
    status = 'pending',
    updated_at = NOW()
WHERE task_id = $1
RETURNING task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, retry_count, created_at, updated_at
`

type UpdateTaskValueParams struct {
	TaskID string         `json:"task_id"`
	Value  pgtype.Numeric `json:"value"`
}

func (q *Queries) UpdateTaskValue(ctx context.Context, arg UpdateTaskValueParams) (Tasks, error) {
	row := q.db.QueryRow(ctx, updateTaskValue, arg.TaskID, arg.Value)
	var i Tasks
	err := row.Scan(
		&i.TaskID,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Value,
		&i.Epoch,
		&i.Status,
		&i.RequiredConfirmations,
		&i.RetryCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
