// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package tasks

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldTasks = `-- name: CleanupOldTasks :exec
DELETE FROM tasks
WHERE created_at < NOW() - INTERVAL '24 hours'
AND status IN ('completed', 'failed')
`

func (q *Queries) CleanupOldTasks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldTasks)
	return err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
    task_id,
    target_address,
    chain_id,
    block_number,
    timestamp,
    epoch,
    key,
    value,
    status,
    required_confirmations
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, current_confirmations, last_checked_block, created_at, updated_at
`

type CreateTaskParams struct {
	TaskID                string         `json:"task_id"`
	TargetAddress         string         `json:"target_address"`
	ChainID               int32          `json:"chain_id"`
	BlockNumber           pgtype.Numeric `json:"block_number"`
	Timestamp             pgtype.Numeric `json:"timestamp"`
	Epoch                 int32          `json:"epoch"`
	Key                   pgtype.Numeric `json:"key"`
	Value                 pgtype.Numeric `json:"value"`
	Status                string         `json:"status"`
	RequiredConfirmations pgtype.Int4    `json:"required_confirmations"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.TaskID,
		arg.TargetAddress,
		arg.ChainID,
		arg.BlockNumber,
		arg.Timestamp,
		arg.Epoch,
		arg.Key,
		arg.Value,
		arg.Status,
		arg.RequiredConfirmations,
	)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Value,
		&i.Epoch,
		&i.Status,
		&i.RequiredConfirmations,
		&i.CurrentConfirmations,
		&i.LastCheckedBlock,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, current_confirmations, last_checked_block, created_at, updated_at FROM tasks
WHERE task_id = $1
`

func (q *Queries) GetTaskByID(ctx context.Context, taskID string) (Task, error) {
	row := q.db.QueryRow(ctx, getTaskByID, taskID)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Value,
		&i.Epoch,
		&i.Status,
		&i.RequiredConfirmations,
		&i.CurrentConfirmations,
		&i.LastCheckedBlock,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listConfirmingTasks = `-- name: ListConfirmingTasks :many
SELECT task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, current_confirmations, last_checked_block, created_at, updated_at FROM tasks 
WHERE status = 'confirming'
ORDER BY created_at DESC
`

func (q *Queries) ListConfirmingTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.Query(ctx, listConfirmingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.TaskID,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.BlockNumber,
			&i.Timestamp,
			&i.Value,
			&i.Epoch,
			&i.Status,
			&i.RequiredConfirmations,
			&i.CurrentConfirmations,
			&i.LastCheckedBlock,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingTasks = `-- name: ListPendingTasks :many
SELECT task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, current_confirmations, last_checked_block, created_at, updated_at FROM tasks
WHERE status = 'pending'
ORDER BY created_at ASC
`

func (q *Queries) ListPendingTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.Query(ctx, listPendingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.TaskID,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.BlockNumber,
			&i.Timestamp,
			&i.Value,
			&i.Epoch,
			&i.Status,
			&i.RequiredConfirmations,
			&i.CurrentConfirmations,
			&i.LastCheckedBlock,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTaskCompleted = `-- name: UpdateTaskCompleted :exec
UPDATE tasks
SET status = 'completed',
    updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskCompleted(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, updateTaskCompleted, taskID)
	return err
}

const updateTaskConfirmations = `-- name: UpdateTaskConfirmations :exec
UPDATE tasks 
SET current_confirmations = $1,
    last_checked_block = $2,
    updated_at = NOW()
WHERE task_id = $3
`

type UpdateTaskConfirmationsParams struct {
	CurrentConfirmations pgtype.Int4    `json:"current_confirmations"`
	LastCheckedBlock     pgtype.Numeric `json:"last_checked_block"`
	TaskID               string         `json:"task_id"`
}

func (q *Queries) UpdateTaskConfirmations(ctx context.Context, arg UpdateTaskConfirmationsParams) error {
	_, err := q.db.Exec(ctx, updateTaskConfirmations, arg.CurrentConfirmations, arg.LastCheckedBlock, arg.TaskID)
	return err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :one
UPDATE tasks
SET status = $2,
    updated_at = NOW()
WHERE task_id = $1
RETURNING task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, current_confirmations, last_checked_block, created_at, updated_at
`

type UpdateTaskStatusParams struct {
	TaskID string `json:"task_id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (Task, error) {
	row := q.db.QueryRow(ctx, updateTaskStatus, arg.TaskID, arg.Status)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Value,
		&i.Epoch,
		&i.Status,
		&i.RequiredConfirmations,
		&i.CurrentConfirmations,
		&i.LastCheckedBlock,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTaskToPending = `-- name: UpdateTaskToPending :exec
UPDATE tasks 
SET status = 'pending', updated_at = NOW()
WHERE task_id = $1
`

func (q *Queries) UpdateTaskToPending(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, updateTaskToPending, taskID)
	return err
}

const updateTaskValue = `-- name: UpdateTaskValue :one
UPDATE tasks
SET value = $2,
    status = 'pending',
    updated_at = NOW()
WHERE task_id = $1
RETURNING task_id, chain_id, target_address, key, block_number, timestamp, value, epoch, status, required_confirmations, current_confirmations, last_checked_block, created_at, updated_at
`

type UpdateTaskValueParams struct {
	TaskID string         `json:"task_id"`
	Value  pgtype.Numeric `json:"value"`
}

func (q *Queries) UpdateTaskValue(ctx context.Context, arg UpdateTaskValueParams) (Task, error) {
	row := q.db.QueryRow(ctx, updateTaskValue, arg.TaskID, arg.Value)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Value,
		&i.Epoch,
		&i.Status,
		&i.RequiredConfirmations,
		&i.CurrentConfirmations,
		&i.LastCheckedBlock,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
