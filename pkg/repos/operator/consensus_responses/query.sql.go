// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package consensus_responses

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createConsensusResponse = `-- name: CreateConsensusResponse :one
INSERT INTO consensus_responses (
    task_id,
    epoch,
    status,
    aggregated_signatures,
    operator_signatures,
    consensus_reached_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, task_id, epoch, status, value, block_number, chain_id, target_address, key, aggregated_signatures, operator_signatures, total_weight, consensus_reached_at, created_at, updated_at
`

type CreateConsensusResponseParams struct {
	TaskID               string           `json:"task_id"`
	Epoch                int32            `json:"epoch"`
	Status               string           `json:"status"`
	AggregatedSignatures []byte           `json:"aggregated_signatures"`
	OperatorSignatures   []byte           `json:"operator_signatures"`
	ConsensusReachedAt   pgtype.Timestamp `json:"consensus_reached_at"`
}

func (q *Queries) CreateConsensusResponse(ctx context.Context, arg CreateConsensusResponseParams) (ConsensusResponse, error) {
	row := q.db.QueryRow(ctx, createConsensusResponse,
		arg.TaskID,
		arg.Epoch,
		arg.Status,
		arg.AggregatedSignatures,
		arg.OperatorSignatures,
		arg.ConsensusReachedAt,
	)
	var i ConsensusResponse
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Epoch,
		&i.Status,
		&i.Value,
		&i.BlockNumber,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.AggregatedSignatures,
		&i.OperatorSignatures,
		&i.TotalWeight,
		&i.ConsensusReachedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteConsensusResponse = `-- name: DeleteConsensusResponse :exec
DELETE FROM consensus_responses
WHERE task_id = $1
`

func (q *Queries) DeleteConsensusResponse(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, deleteConsensusResponse, taskID)
	return err
}

const getConsensusResponse = `-- name: GetConsensusResponse :one
SELECT id, task_id, epoch, status, value, block_number, chain_id, target_address, key, aggregated_signatures, operator_signatures, total_weight, consensus_reached_at, created_at, updated_at FROM consensus_responses
WHERE task_id = $1 LIMIT 1
`

func (q *Queries) GetConsensusResponse(ctx context.Context, taskID string) (ConsensusResponse, error) {
	row := q.db.QueryRow(ctx, getConsensusResponse, taskID)
	var i ConsensusResponse
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Epoch,
		&i.Status,
		&i.Value,
		&i.BlockNumber,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.AggregatedSignatures,
		&i.OperatorSignatures,
		&i.TotalWeight,
		&i.ConsensusReachedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPendingConsensus = `-- name: ListPendingConsensus :many
SELECT id, task_id, epoch, status, value, block_number, chain_id, target_address, key, aggregated_signatures, operator_signatures, total_weight, consensus_reached_at, created_at, updated_at FROM consensus_responses
WHERE status = 'pending'
ORDER BY created_at DESC
`

func (q *Queries) ListPendingConsensus(ctx context.Context) ([]ConsensusResponse, error) {
	rows, err := q.db.Query(ctx, listPendingConsensus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConsensusResponse{}
	for rows.Next() {
		var i ConsensusResponse
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Epoch,
			&i.Status,
			&i.Value,
			&i.BlockNumber,
			&i.ChainID,
			&i.TargetAddress,
			&i.Key,
			&i.AggregatedSignatures,
			&i.OperatorSignatures,
			&i.TotalWeight,
			&i.ConsensusReachedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConsensusStatus = `-- name: UpdateConsensusStatus :one
UPDATE consensus_responses
SET status = $2,
    consensus_reached_at = $3,
    aggregated_signatures = $4,
    operator_signatures = $5
WHERE task_id = $1
RETURNING id, task_id, epoch, status, value, block_number, chain_id, target_address, key, aggregated_signatures, operator_signatures, total_weight, consensus_reached_at, created_at, updated_at
`

type UpdateConsensusStatusParams struct {
	TaskID               string           `json:"task_id"`
	Status               string           `json:"status"`
	ConsensusReachedAt   pgtype.Timestamp `json:"consensus_reached_at"`
	AggregatedSignatures []byte           `json:"aggregated_signatures"`
	OperatorSignatures   []byte           `json:"operator_signatures"`
}

func (q *Queries) UpdateConsensusStatus(ctx context.Context, arg UpdateConsensusStatusParams) (ConsensusResponse, error) {
	row := q.db.QueryRow(ctx, updateConsensusStatus,
		arg.TaskID,
		arg.Status,
		arg.ConsensusReachedAt,
		arg.AggregatedSignatures,
		arg.OperatorSignatures,
	)
	var i ConsensusResponse
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Epoch,
		&i.Status,
		&i.Value,
		&i.BlockNumber,
		&i.ChainID,
		&i.TargetAddress,
		&i.Key,
		&i.AggregatedSignatures,
		&i.OperatorSignatures,
		&i.TotalWeight,
		&i.ConsensusReachedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
