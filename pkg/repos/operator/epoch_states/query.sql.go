// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package epoch_states

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEpochState = `-- name: GetEpochState :one
SELECT epoch_number, block_number, minimum_weight, total_weight, threshold_weight, updated_at FROM epoch_states
WHERE epoch_number = $1
`

func (q *Queries) GetEpochState(ctx context.Context, epochNumber uint32) (EpochState, error) {
	row := q.db.QueryRow(ctx, getEpochState, epochNumber)
	var i EpochState
	err := row.Scan(
		&i.EpochNumber,
		&i.BlockNumber,
		&i.MinimumWeight,
		&i.TotalWeight,
		&i.ThresholdWeight,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestEpochState = `-- name: GetLatestEpochState :one
SELECT epoch_number, block_number, minimum_weight, total_weight, threshold_weight, updated_at FROM epoch_states
ORDER BY epoch_number DESC
LIMIT 1
`

func (q *Queries) GetLatestEpochState(ctx context.Context) (EpochState, error) {
	row := q.db.QueryRow(ctx, getLatestEpochState)
	var i EpochState
	err := row.Scan(
		&i.EpochNumber,
		&i.BlockNumber,
		&i.MinimumWeight,
		&i.TotalWeight,
		&i.ThresholdWeight,
		&i.UpdatedAt,
	)
	return i, err
}

const listEpochStates = `-- name: ListEpochStates :many
SELECT epoch_number, block_number, minimum_weight, total_weight, threshold_weight, updated_at FROM epoch_states
ORDER BY epoch_number DESC
LIMIT $1
`

func (q *Queries) ListEpochStates(ctx context.Context, limit int32) ([]EpochState, error) {
	rows, err := q.db.Query(ctx, listEpochStates, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EpochState{}
	for rows.Next() {
		var i EpochState
		if err := rows.Scan(
			&i.EpochNumber,
			&i.BlockNumber,
			&i.MinimumWeight,
			&i.TotalWeight,
			&i.ThresholdWeight,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEpochState = `-- name: UpsertEpochState :one
INSERT INTO epoch_states (
    epoch_number,
    block_number,
    minimum_weight,
    total_weight,
    threshold_weight,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (epoch_number) DO UPDATE
SET
    block_number = EXCLUDED.block_number,
    minimum_weight = EXCLUDED.minimum_weight,
    total_weight = EXCLUDED.total_weight,
    threshold_weight = EXCLUDED.threshold_weight,
    updated_at = EXCLUDED.updated_at
RETURNING epoch_number, block_number, minimum_weight, total_weight, threshold_weight, updated_at
`

type UpsertEpochStateParams struct {
	EpochNumber     uint32             `json:"epoch_number"`
	BlockNumber     uint64             `json:"block_number"`
	MinimumWeight   pgtype.Numeric     `json:"minimum_weight"`
	TotalWeight     pgtype.Numeric     `json:"total_weight"`
	ThresholdWeight pgtype.Numeric     `json:"threshold_weight"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpsertEpochState(ctx context.Context, arg UpsertEpochStateParams) (EpochState, error) {
	row := q.db.QueryRow(ctx, upsertEpochState,
		arg.EpochNumber,
		arg.BlockNumber,
		arg.MinimumWeight,
		arg.TotalWeight,
		arg.ThresholdWeight,
		arg.UpdatedAt,
	)
	var i EpochState
	err := row.Scan(
		&i.EpochNumber,
		&i.BlockNumber,
		&i.MinimumWeight,
		&i.TotalWeight,
		&i.ThresholdWeight,
		&i.UpdatedAt,
	)
	return i, err
}
