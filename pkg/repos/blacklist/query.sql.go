// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v2.3.0-wicked-fork
// source: query.sql

package blacklist

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/rs/zerolog/log"
)

const cleanExpiredBlocks = `-- name: CleanExpiredBlocks :exec
DELETE FROM blacklist
WHERE expires_at < NOW()
`

// -- timeout: 5s
// -- invalidate: IsBlocked
func (q *Queries) CleanExpiredBlocks(ctx context.Context, isBlocked *string) error {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*5000)
	defer cancel()
	_, err := q.db.WExec(qctx, "blacklist.CleanExpiredBlocks", cleanExpiredBlocks)
	if err != nil {
		return err
	}
	// invalidate
	_ = q.db.PostExec(func() error {
		anyErr := make(chan error, 1)
		var wg sync.WaitGroup
		wg.Add(1)
		go func() {
			defer wg.Done()
			if isBlocked != nil {
				key := "blacklist:IsBlocked:" + hashIfLong(fmt.Sprintf("%+v", (*isBlocked)))
				err = q.cache.Invalidate(ctx, key)
				if err != nil {
					log.Ctx(ctx).Error().Err(err).Msgf(
						"Failed to invalidate: %s", key)
					anyErr <- err
				}
			}
		}()
		wg.Wait()
		close(anyErr)
		return <-anyErr
	})
	return nil
}

const incrementViolationCount = `-- name: IncrementViolationCount :one
INSERT INTO blacklist (
    peer_id,
    violation_count,
    expires_at
) VALUES (
    $1,
    $2,
    $3
)
ON CONFLICT (peer_id) DO UPDATE
SET 
    violation_count = blacklist.violation_count + EXCLUDED.violation_count,
    expires_at = EXCLUDED.expires_at,
    updated_at = NOW()
RETURNING peer_id, violation_count, created_at, updated_at, expires_at
`

type IncrementViolationCountParams struct {
	PeerID         string     `json:"peer_id"`
	ViolationCount int32      `json:"violation_count"`
	ExpiresAt      *time.Time `json:"expires_at"`
}

// -- timeout: 500ms
// -- invalidate: IsBlocked
func (q *Queries) IncrementViolationCount(ctx context.Context, arg IncrementViolationCountParams, isBlocked *string) (*Blacklist, error) {
	return _IncrementViolationCount(ctx, q, arg, isBlocked)
}

func _IncrementViolationCount(ctx context.Context, q CacheWGConn, arg IncrementViolationCountParams, isBlocked *string) (*Blacklist, error) {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*500)
	defer cancel()
	row := q.GetConn().WQueryRow(qctx, "blacklist.IncrementViolationCount", incrementViolationCount, arg.PeerID, arg.ViolationCount, arg.ExpiresAt)
	var i *Blacklist = new(Blacklist)
	err := row.Scan(
		&i.PeerID,
		&i.ViolationCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	if err == pgx.ErrNoRows {
		return (*Blacklist)(nil), nil
	} else if err != nil {
		return nil, err
	}

	// invalidate
	_ = q.GetConn().PostExec(func() error {
		anyErr := make(chan error, 1)
		var wg sync.WaitGroup
		wg.Add(1)
		go func() {
			defer wg.Done()
			if isBlocked != nil {
				key := "blacklist:IsBlocked:" + hashIfLong(fmt.Sprintf("%+v", (*isBlocked)))
				err = q.GetCache().Invalidate(ctx, key)
				if err != nil {
					log.Ctx(ctx).Error().Err(err).Msgf(
						"Failed to invalidate: %s", key)
					anyErr <- err
				}
			}
		}()
		wg.Wait()
		close(anyErr)
		return <-anyErr
	})
	return i, err
}

const isBlocked = `-- name: IsBlocked :one
SELECT EXISTS (
    SELECT 1 FROM blacklist
    WHERE peer_id = $1
    AND violation_count >= 3
    AND (expires_at IS NULL OR expires_at > NOW())
) as is_blocked
`

// -- cache: 24h
// -- timeout: 100ms
func (q *Queries) IsBlocked(ctx context.Context, peerID string) (*bool, error) {
	return _IsBlocked(ctx, q.AsReadOnly(), peerID)
}

func (q *ReadOnlyQueries) IsBlocked(ctx context.Context, peerID string) (*bool, error) {
	return _IsBlocked(ctx, q, peerID)
}

func _IsBlocked(ctx context.Context, q CacheQuerierConn, peerID string) (*bool, error) {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*100)
	defer cancel()
	q.GetConn().CountIntent("blacklist.IsBlocked")
	dbRead := func() (any, time.Duration, error) {
		cacheDuration := time.Duration(time.Millisecond * 86400000)
		row := q.GetConn().WQueryRow(qctx, "blacklist.IsBlocked", isBlocked, peerID)
		var is_blocked *bool = new(bool)
		err := row.Scan(is_blocked)
		if err == pgx.ErrNoRows {
			return (*bool)(nil), cacheDuration, nil
		}
		return is_blocked, cacheDuration, err
	}
	if q.GetCache() == nil {
		is_blocked, _, err := dbRead()
		return is_blocked.(*bool), err
	}

	var is_blocked *bool
	err := q.GetCache().GetWithTtl(qctx, "blacklist:IsBlocked:"+hashIfLong(fmt.Sprintf("%+v", peerID)), &is_blocked, dbRead, false, false)
	if err != nil {
		return nil, err
	}

	return is_blocked, err
}

const listBlacklist = `-- name: ListBlacklist :many
SELECT peer_id, violation_count, created_at, updated_at, expires_at FROM blacklist
WHERE expires_at IS NULL OR expires_at > NOW()
ORDER BY created_at DESC
LIMIT COALESCE($2::int, 100)
OFFSET COALESCE($1::int, 0)
`

type ListBlacklistParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

// -- timeout: 500ms
func (q *Queries) ListBlacklist(ctx context.Context, arg ListBlacklistParams) ([]Blacklist, error) {
	return _ListBlacklist(ctx, q.AsReadOnly(), arg)
}

func (q *ReadOnlyQueries) ListBlacklist(ctx context.Context, arg ListBlacklistParams) ([]Blacklist, error) {
	return _ListBlacklist(ctx, q, arg)
}

func _ListBlacklist(ctx context.Context, q CacheQuerierConn, arg ListBlacklistParams) ([]Blacklist, error) {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*500)
	defer cancel()
	q.GetConn().CountIntent("blacklist.ListBlacklist")
	rows, err := q.GetConn().WQuery(qctx, "blacklist.ListBlacklist", listBlacklist, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Blacklist
	for rows.Next() {
		var i *Blacklist = new(Blacklist)
		if err := rows.Scan(
			&i.PeerID,
			&i.ViolationCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, *i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return items, err
}

const unblockNode = `-- name: UnblockNode :exec
DELETE FROM blacklist 
WHERE peer_id = $1
`

// -- timeout: 500ms
// -- invalidate: IsBlocked
func (q *Queries) UnblockNode(ctx context.Context, peerID string, isBlocked *string) error {
	qctx, cancel := context.WithTimeout(ctx, time.Millisecond*500)
	defer cancel()
	_, err := q.db.WExec(qctx, "blacklist.UnblockNode", unblockNode, peerID)
	if err != nil {
		return err
	}
	// invalidate
	_ = q.db.PostExec(func() error {
		anyErr := make(chan error, 1)
		var wg sync.WaitGroup
		wg.Add(1)
		go func() {
			defer wg.Done()
			if isBlocked != nil {
				key := "blacklist:IsBlocked:" + hashIfLong(fmt.Sprintf("%+v", (*isBlocked)))
				err = q.cache.Invalidate(ctx, key)
				if err != nil {
					log.Ctx(ctx).Error().Err(err).Msgf(
						"Failed to invalidate: %s", key)
					anyErr <- err
				}
			}
		}()
		wg.Wait()
		close(anyErr)
		return <-anyErr
	})
	return nil
}

//// auto generated functions

func (q *Queries) Dump(ctx context.Context, beforeDump ...BeforeDump) ([]byte, error) {
	sql := "SELECT peer_id,violation_count,created_at,updated_at,expires_at FROM \"blacklist\" ORDER BY peer_id,violation_count,created_at,updated_at,expires_at ASC;"
	rows, err := q.db.WQuery(ctx, "blacklist.Dump", sql)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Blacklist
	for rows.Next() {
		var v Blacklist
		if err := rows.Scan(&v.PeerID, &v.ViolationCount, &v.CreatedAt, &v.UpdatedAt, &v.ExpiresAt); err != nil {
			return nil, err
		}
		for _, applyBeforeDump := range beforeDump {
			applyBeforeDump(&v)
		}
		items = append(items, v)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	bytes, err := json.MarshalIndent(items, "", "  ")
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

func (q *Queries) Load(ctx context.Context, data []byte) error {
	sql := "INSERT INTO \"blacklist\" (peer_id,violation_count,created_at,updated_at,expires_at) VALUES ($1,$2,$3,$4,$5);"
	rows := make([]Blacklist, 0)
	err := json.Unmarshal(data, &rows)
	if err != nil {
		return err
	}
	for _, row := range rows {
		_, err := q.db.WExec(ctx, "blacklist.Load", sql, row.PeerID, row.ViolationCount, row.CreatedAt, row.UpdatedAt, row.ExpiresAt)
		if err != nil {
			return err
		}
	}
	return nil
}

func hashIfLong(v string) string {
	if len(v) > 64 {
		hash := sha256.Sum256([]byte(v))
		return "h(" + hex.EncodeToString(hash[:]) + ")"
	}
	return v
}

func ptrStr[T any](v *T) string {
	if v == nil {
		return "<nil>"
	}
	return fmt.Sprintf("%+v", *v)
}

// eliminate unused error
var _ = log.Logger
var _ = fmt.Sprintf("")
var _ = time.Now()
var _ = json.RawMessage{}
var _ = sha256.Sum256(nil)
var _ = hex.EncodeToString(nil)
var _ = sync.WaitGroup{}
